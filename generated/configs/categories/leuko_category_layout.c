/* generated by gen_rule_struct.c - category source - do not edit */
#include "categories/leuko_category_layout.h"
#include <stdlib.h>
#include <string.h>

static char *leuko_strdup(const char *s) { if (!s) return NULL; char *r = malloc(strlen(s)+1); if (r) strcpy(r, s); return r; }

void leuko_category_layout_init_defaults(leuko_category_layout_t *out) {
    out->enabled = true;
    out->severity = leuko_strdup("convention");
    out->include = NULL;
    out->include_len = 0;
    out->exclude = NULL;
    out->exclude_len = 0;
    leuko_layout_indentation_consistency_init_defaults(&out->indentation_consistency);
}

int leuko_category_layout_from_json(leuko_category_layout_t *out, const cJSON *json) {
    if (!cJSON_IsObject(json)) return -1;
    /* rules */
    cJSON *rules = cJSON_GetObjectItemCaseSensitive(json, "rules");
    if (rules && cJSON_IsObject(rules)) {
        cJSON *r_indentation_consistency = cJSON_GetObjectItemCaseSensitive(rules, "indentation_consistency"); if (r_indentation_consistency) { if (leuko_layout_indentation_consistency_from_json(&out->indentation_consistency, r_indentation_consistency) != 0) return -1; }
    }
    /* include */
    cJSON *inc = cJSON_GetObjectItemCaseSensitive(json, "include"); if (inc) { if (!cJSON_IsArray(inc)) return -1; size_t n = cJSON_GetArraySize(inc); if (out->include) { for (size_t i=0;i<out->include_len;++i) free(out->include[i]); free(out->include); out->include = NULL; out->include_len = 0; } out->include = malloc(sizeof(char*) * n); if (!out->include && n>0) return -1; out->include_len = n; for (size_t i=0;i<n;++i) { cJSON *it = cJSON_GetArrayItem(inc, i); if (!cJSON_IsString(it) || !it->valuestring) return -1; out->include[i] = leuko_strdup(it->valuestring); } }
    /* exclude */
    cJSON *exc = cJSON_GetObjectItemCaseSensitive(json, "exclude"); if (exc) { if (!cJSON_IsArray(exc)) return -1; size_t m = cJSON_GetArraySize(exc); if (out->exclude) { for (size_t i=0;i<out->exclude_len;++i) free(out->exclude[i]); free(out->exclude); out->exclude = NULL; out->exclude_len = 0; } out->exclude = malloc(sizeof(char*) * m); if (!out->exclude && m>0) return -1; out->exclude_len = m; for (size_t i=0;i<m;++i) { cJSON *it = cJSON_GetArrayItem(exc, i); if (!cJSON_IsString(it) || !it->valuestring) return -1; out->exclude[i] = leuko_strdup(it->valuestring); } }
    return 0;
}

void leuko_category_layout_free(leuko_category_layout_t *out) { if (!out) return; leuko_layout_indentation_consistency_free(&out->indentation_consistency); if (out->include) { for (size_t i=0;i<out->include_len;++i) free(out->include[i]); free(out->include); out->include = NULL; out->include_len = 0; } if (out->exclude) { for (size_t i=0;i<out->exclude_len;++i) free(out->exclude[i]); free(out->exclude); out->exclude = NULL; out->exclude_len = 0; } free(out->severity); }

