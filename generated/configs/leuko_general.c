/* generated by gen_rule_struct.c - general source - do not edit */
#include "leuko_general.h"
#include <stdlib.h>
#include <string.h>

static char *leuko_strdup(const char *s) { if (!s) return NULL; char *r = malloc(strlen(s)+1); if (r) strcpy(r, s); return r; }

void leuko_general_init_defaults(leuko_general_t *out) {
    out->enabled = true;
    out->severity = leuko_strdup("convention");
    out->include = NULL;
    out->include_len = 0;
    out->exclude = NULL;
    out->exclude_len = 0;
}

int leuko_general_from_json(leuko_general_t *out, const cJSON *json) {
    if (!cJSON_IsObject(json)) return -1;
    cJSON *e = cJSON_GetObjectItemCaseSensitive(json, "enabled"); if (e) { if (cJSON_IsBool(e)) out->enabled = cJSON_IsTrue(e); else return -1; }
    cJSON *sev = cJSON_GetObjectItemCaseSensitive(json, "severity"); if (sev) { if (cJSON_IsString(sev) && sev->valuestring) { free(out->severity); out->severity = leuko_strdup(sev->valuestring); } else return -1; }
    /* include */
    cJSON *inc = cJSON_GetObjectItemCaseSensitive(json, "include"); if (inc) { if (!cJSON_IsArray(inc)) return -1; size_t n = cJSON_GetArraySize(inc); if (out->include) { for (size_t i=0;i<out->include_len;++i) free(out->include[i]); free(out->include); out->include = NULL; out->include_len = 0; } out->include = malloc(sizeof(char*) * n); if (!out->include && n>0) return -1; out->include_len = n; for (size_t i=0;i<n;++i) { cJSON *it = cJSON_GetArrayItem(inc, i); if (!cJSON_IsString(it) || !it->valuestring) return -1; out->include[i] = leuko_strdup(it->valuestring); } }
    /* exclude */
    cJSON *exc = cJSON_GetObjectItemCaseSensitive(json, "exclude"); if (exc) { if (!cJSON_IsArray(exc)) return -1; size_t m = cJSON_GetArraySize(exc); if (out->exclude) { for (size_t i=0;i<out->exclude_len;++i) free(out->exclude[i]); free(out->exclude); out->exclude = NULL; out->exclude_len = 0; } out->exclude = malloc(sizeof(char*) * m); if (!out->exclude && m>0) return -1; out->exclude_len = m; for (size_t i=0;i<m;++i) { cJSON *it = cJSON_GetArrayItem(exc, i); if (!cJSON_IsString(it) || !it->valuestring) return -1; out->exclude[i] = leuko_strdup(it->valuestring); } }
    return 0;
}

void leuko_general_free(leuko_general_t *out) { if (!out) return; if (out->severity) free(out->severity); if (out->include) { for (size_t i=0;i<out->include_len;++i) free(out->include[i]); free(out->include); out->include = NULL; out->include_len = 0; } if (out->exclude) { for (size_t i=0;i<out->exclude_len;++i) free(out->exclude[i]); free(out->exclude); out->exclude = NULL; out->exclude_len = 0; } }
