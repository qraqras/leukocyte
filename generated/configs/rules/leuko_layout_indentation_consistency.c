/* generated by gen_rule_struct.c - do not edit */
#include "rules/leuko_layout_indentation_consistency.h"
#include <stdlib.h>
#include <string.h>

static char *leuko_strdup(const char *s) { if (!s) return NULL; char *r = malloc(strlen(s)+1); if (r) strcpy(r, s); return r; }

void leuko_layout_indentation_consistency_init_defaults(leuko_layout_indentation_consistency_t *out) {
    out->enabled = true;
    out->severity = leuko_strdup("convention");
    out->include = NULL;
    out->include_len = 0;
    out->exclude = NULL;
    out->exclude_len = 0;
    out->enforced_style = leuko_strdup("space");
    out->indent_width = 2;
}

int leuko_layout_indentation_consistency_from_json(leuko_layout_indentation_consistency_t *out, const cJSON *json) {
    if (!cJSON_IsObject(json)) return -1;
    cJSON *e = cJSON_GetObjectItemCaseSensitive(json, "enabled"); if (e) { if (cJSON_IsBool(e)) out->enabled = cJSON_IsTrue(e); else return -1; }
    cJSON *sev = cJSON_GetObjectItemCaseSensitive(json, "severity"); if (sev) { if (cJSON_IsString(sev) && sev->valuestring) { free(out->severity); out->severity = leuko_strdup(sev->valuestring); } else return -1; }
    /* include */
    cJSON *inc = cJSON_GetObjectItemCaseSensitive(json, "include"); if (inc) { if (!cJSON_IsArray(inc)) return -1; size_t n = cJSON_GetArraySize(inc); if (out->include) { for (size_t i=0;i<out->include_len;++i) free(out->include[i]); free(out->include); out->include = NULL; out->include_len = 0; } out->include = malloc(sizeof(char*) * n); if (!out->include && n>0) return -1; out->include_len = n; for (size_t i=0;i<n;++i) { cJSON *it = cJSON_GetArrayItem(inc, i); if (!cJSON_IsString(it) || !it->valuestring) return -1; out->include[i] = leuko_strdup(it->valuestring); } }
    /* exclude */
    cJSON *exc = cJSON_GetObjectItemCaseSensitive(json, "exclude"); if (exc) { if (!cJSON_IsArray(exc)) return -1; size_t m = cJSON_GetArraySize(exc); if (out->exclude) { for (size_t i=0;i<out->exclude_len;++i) free(out->exclude[i]); free(out->exclude); out->exclude = NULL; out->exclude_len = 0; } out->exclude = malloc(sizeof(char*) * m); if (!out->exclude && m>0) return -1; out->exclude_len = m; for (size_t i=0;i<m;++i) { cJSON *it = cJSON_GetArrayItem(exc, i); if (!cJSON_IsString(it) || !it->valuestring) return -1; out->exclude[i] = leuko_strdup(it->valuestring); } }
    cJSON *enforced_style_j = cJSON_GetObjectItemCaseSensitive(json, "enforced_style"); if (enforced_style_j) { if (cJSON_IsString(enforced_style_j) && enforced_style_j->valuestring) { free(out->enforced_style); out->enforced_style = leuko_strdup(enforced_style_j->valuestring); } else return -1; }
    cJSON *indent_width_j = cJSON_GetObjectItemCaseSensitive(json, "indent_width"); if (indent_width_j) { if (cJSON_IsNumber(indent_width_j)) out->indent_width = indent_width_j->valueint; else return -1; }
    return 0;
}

void leuko_layout_indentation_consistency_free(leuko_layout_indentation_consistency_t *p) { if (!p) return; free(p->severity); if (p->include) { for (size_t i=0;i<p->include_len;++i) free(p->include[i]); free(p->include); p->include = NULL; p->include_len = 0; } if (p->exclude) { for (size_t i=0;i<p->exclude_len;++i) free(p->exclude[i]); free(p->exclude); p->exclude = NULL; p->exclude_len = 0; }}

